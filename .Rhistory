scale_y_continuous(labels = scales::dollar) +
labs(
x = "Building age (years)",
y = "Sale price (USD)",
title = "Price vs Building Age",
subtitle = "Newer buildings tend to transact higher, but there's a ton of variance"
) +
theme_minimal(base_size = 11)
## Combine into one figure (2x2 grid)
figure_3_structural <- (p_beds | p_baths) / (p_area | p_age)
figure_3_structural
#| label: Spatial-features
#| fig.width: 10
#| fig.height: 8
# Build plotting data frame for spatial/context features
plot_spatial <- sales_data %>%
select(
sale_price,
dist_park_mi,
violent_2blocks,
foodretail_1mi_count,
med_hh_income
) %>%
filter(
!is.na(sale_price),
sale_price > 0,
!is.na(dist_park_mi),
!is.na(violent_2blocks),
!is.na(foodretail_1mi_count),
!is.na(med_hh_income)
)
## Plot A: Price vs distance to nearest park (miles)
p_park <- ggplot(plot_spatial,
aes(x = dist_park_mi, y = sale_price)) +
geom_point(alpha = 0.15, size = 0.6, color = "darkgreen") +
geom_smooth(method = "lm", se = FALSE,
linewidth = 0.7, color = "black") +
scale_y_continuous(labels = scales::dollar) +
labs(
x = "Distance to nearest park (miles)",
y = "Sale price (USD)",
title = "Parks & Property Value",
subtitle = "Homes farther from parks tend to sell for slightly less,\nthough the effect is noisy"
) +
theme_minimal(base_size = 11)
## Plot B: Price vs violent incidents within ~2 blocks
p_crime <- ggplot(plot_spatial,
aes(x = violent_2blocks, y = sale_price)) +
geom_point(alpha = 0.15, size = 0.6, color = "firebrick") +
geom_smooth(method = "lm", se = FALSE,
linewidth = 0.7, color = "black") +
scale_y_continuous(labels = scales::dollar) +
labs(
x = "Violent incidents within ~600 ft",
y = "Sale price (USD)",
title = "Local Violent Crime",
subtitle = "Higher recent violent incident counts are associated with\nlower observed sale prices"
) +
theme_minimal(base_size = 11)
## Plot C: Price vs food access (# of retailers within 1 mile)
p_food <- ggplot(plot_spatial,
aes(x = foodretail_1mi_count, y = sale_price)) +
geom_point(alpha = 0.15, size = 0.6, color = "goldenrod4") +
geom_smooth(method = "lm", se = FALSE,
linewidth = 0.7, color = "black") +
scale_y_continuous(labels = scales::dollar) +
labs(
x = "Food retailers within 1 mile",
y = "Sale price (USD)",
title = "Retail Food Environment",
subtitle = "More nearby food retail sometimes tracks denser, more affordable areas"
) +
theme_minimal(base_size = 11)
## Plot D: Price vs neighborhood income (ACS)
p_income <- ggplot(plot_spatial,
aes(x = med_hh_income, y = sale_price)) +
geom_point(alpha = 0.15, size = 0.6, color = "navy") +
geom_smooth(method = "lm", se = FALSE,
linewidth = 0.7, color = "black") +
scale_x_continuous(labels = scales::dollar) +
scale_y_continuous(labels = scales::dollar) +
labs(
x = "Median household income (USD, tract)",
y = "Sale price (USD)",
title = "Income & Home Prices",
subtitle = "Higher-income Census tracts show systematically higher sale prices"
) +
theme_minimal(base_size = 11)
## Arrange in a 2x2 panel
figure_4_spatial <- (p_park | p_crime) / (p_food | p_income)
figure_4_spatial
#| label: creative-bubble-map
#| fig.width: 10
#| fig.height: 8
acs_vars <- c(
med_income   = "B19013_001",
poverty_rate = "S1701_C02_001"
)
acs_tracts <- get_acs(
geography = "tract",
state     = "PA",
county    = "Philadelphia",
variables = acs_vars,
year      = 2023,
survey    = "acs5",
geometry  = TRUE,
cache_table = TRUE
) %>%
select(GEOID, variable, estimate, geometry) %>%
st_transform(st_crs(geo_clean)) %>%
pivot_wider(names_from = variable, values_from = estimate) %>%
st_as_sf()
acs_to_neigh <- acs_tracts %>%
st_point_on_surface() %>%
st_join(neigh %>% select(NAME)) %>%
st_drop_geometry() %>%
filter(!is.na(NAME)) %>%
group_by(NAME) %>%
summarise(
med_income_acs   = median(med_income, na.rm = TRUE),
poverty_rate_acs = median(poverty_rate, na.rm = TRUE)
) %>%
ungroup()
sales_neigh <- sales_data %>%
filter(sale_price > 0) %>%
group_by(neigh_name) %>%
summarise(
n_sales      = n(),
median_price = median(sale_price, na.rm = TRUE)
) %>%
ungroup()
neigh_summary_fixed <- sales_neigh %>%
left_join(acs_to_neigh, by = c("neigh_name" = "NAME")) %>%
drop_na(med_income_acs, poverty_rate_acs)
p_neigh_bubble_fixed <-
ggplot(neigh_summary_fixed,
aes(x = med_income_acs, y = median_price,
size = n_sales, color = poverty_rate_acs)) +
geom_point(alpha = 0.85) +
scale_x_continuous(labels = scales::dollar) +
scale_y_continuous(labels = scales::dollar) +
scale_color_viridis_c(option = "plasma", name = "Poverty rate (%)") +
scale_size_continuous(name = "Sales count", range = c(2, 10)) +
labs(
title = "Neighborhood Economics and Home Prices",
subtitle = "Each point = a neighborhood (2023–2024 sales)\nX: ACS Median household income · Y: Median sale price · Color: ACS poverty rate · Size: sales count",
x = "Median household income (USD)",
y = "Median sale price (USD)"
) +
theme_minimal(base_size = 12) +
theme(legend.position = "right")
p_neigh_bubble_fixed
#| label: Feature-Selection
#| message: false
#| warning: false
#| Results: false
select_data <- sales_data |>
select(year_built, number_of_bathrooms, number_of_bedrooms, basements,
fireplaces, garage_spaces,
general_construction, interior_condition, exterior_condition,
census_tract, neigh_name,
value_multiple, market_value, sale_price, total_area, total_livable_area,
psf, violent_2blocks, petty_1block, dist_park_mi,
vacancy_rate, med_gross_rent, med_hh_income, pct_ba_plus,
pct_white, pct_black, pct_hispanic, pct_asian,
foodretail_1mi_count,
dist_school_public_ft, dist_school_charter_ft,
pct_age_25_44, pct_age_65plus,
poverty_rate, unemployment_rate) |>
filter(number_of_bathrooms > 0, number_of_bedrooms > 0) |>
mutate(age = 2024 - year_built,
basements = dplyr::recode(trimws(as.character(basements)),
"0"="0","A"="1","B"="2","C"="3","D"="4","E"="5",
"F"="6","G"="7","H"="8","I"="9"),
basements = as.integer(basements)) |>
rename(
baths      = number_of_bathrooms,
beds       = number_of_bedrooms,
construction = general_construction,
interior   = interior_condition,
exterior   = exterior_condition,
garage     = garage_spaces,
tract      = census_tract,
neigh      = neigh_name,
mkt_value  = market_value,
area       = total_area,
liv_area   = total_livable_area
)
#| label: Real-Estate-Flags
#| message: false
#| warning: false
#| Results: false
# Intuition: market value should not deviate substantially
# from the sale price
value_range <- select_data |>
summarize(
q1 = quantile(value_multiple, 0.25, na.rm = TRUE),
q3 = quantile(value_multiple, 0.75, na.rm = TRUE),
iqr = q3 - q1,
lower = q1 - 1.5 * iqr,
upper = q3 + 1.5 * iqr)
value_range
# Intuition: psf outliers are likely non-market transactions
psf_range <- select_data |>
summarize(
q1 = quantile(psf, 0.25, na.rm = TRUE),
q3 = quantile(psf, 0.75, na.rm = TRUE),
iqr = q3 - q1,
lower = q1 - 1.5 * iqr,
upper = q3 + 1.5 * iqr)
psf_range
clean_data <- select_data |>
filter(
liv_area > 500,
area > 500,
between(psf, 40, 800),
between(value_multiple, 0.4, 2.0)
) |>
mutate(across(where(is.numeric), ~ round(.x, 2))) |>
drop_na() |>
arrange(liv_area)
clean_data
clean_data$neigh <- as.factor(clean_data$neigh)
clean_data$interior <- as.factor(clean_data$interior)
clean_data$exterior <- as.factor(clean_data$exterior)
clean_data$basements <- as.factor(clean_data$basements)
set.seed(5080) # Set seed for reproducibility
ctrl <- trainControl(method = "cv", number = 10) #10-Fold CV
# Model 1: Structural
cv_m1 <- train(
sale_price ~ beds + baths + basements + interior + exterior + liv_area + poly(age, 2),
data = clean_data, method = "lm", trControl = ctrl
)
# Model 2: + Spatial
cv_m2 <- train(
sale_price ~ beds + baths + basements + interior + exterior + liv_area + poly(age, 2) +
dist_park_mi + foodretail_1mi_count + dist_school_public_ft
+ vacancy_rate + med_gross_rent + med_hh_income + pct_ba_plus + pct_black + pct_white
+ poverty_rate + unemployment_rate + pct_age_25_44 + pct_age_65plus,
data = clean_data, method = "lm", trControl = ctrl
)
# Model 3: + Neighborhood Fixed Effects
cv_m3 <- train(
sale_price ~ beds + baths + basements + interior + exterior + liv_area + poly(age, 2) +
dist_park_mi + foodretail_1mi_count + dist_school_public_ft +
vacancy_rate + med_gross_rent + med_hh_income + pct_ba_plus + pct_black + pct_white +
poverty_rate + unemployment_rate + pct_age_25_44 + pct_age_65plus +
neigh,
data = clean_data, method = "lm", trControl = ctrl
)
# Model 4: + Small Neighborhoods + Mkt Value
clean_data <- clean_data |>
add_count(neigh) |>
mutate(
neigh_cv = if_else(
n < 10,                       # If fewer than 10 sales
"Small_Neighborhoods",        # Group them
as.character(neigh)           # Keep original
),
neigh_cv = as.factor(neigh_cv)
)
cv_m4 <- train(
sale_price ~ beds + baths + basements + interior + exterior + liv_area + poly(age, 2) +
violent_2blocks + dist_park_mi + foodretail_1mi_count + dist_school_public_ft +
vacancy_rate + med_gross_rent + med_hh_income + pct_ba_plus + pct_black + pct_white +
poverty_rate + unemployment_rate + pct_age_25_44 + pct_age_65plus +
mkt_value +
neigh_cv,
data = clean_data, method = "lm", trControl = ctrl
)
# Model 5: + Simpler + Mkt Value
cv_m5 <- train(
sale_price ~ beds + baths + basements + interior + exterior + liv_area + poly(age, 2) +
dist_park_mi + foodretail_1mi_count + dist_school_public_ft +
mkt_value +
neigh_cv,
data = clean_data, method = "lm", trControl = ctrl
)
# Model 6: Simpler Only
cv_m6 <- train(
sale_price ~ beds + baths + basements + interior + exterior + liv_area + poly(age, 2) +
dist_park_mi + foodretail_1mi_count + dist_school_public_ft +
neigh_cv,
data = clean_data, method = "lm", trControl = ctrl
)
# Compare
data.frame(
Model = c("Structural", "Spatial", "Fixed Effects", "Small Neighborhoods + Mkt Value", "Simpler + Mkt Value", "Simpler Only"),
Rsquared = c(cv_m1$results$Rsquared, cv_m2$results$Rsquared, cv_m3$results$Rsquared,
cv_m4$results$Rsquared, cv_m5$results$Rsquared, cv_m6$results$Rsquared),
RMSE = c(cv_m1$results$RMSE, cv_m2$results$RMSE, cv_m3$results$RMSE,
cv_m4$results$RMSE, cv_m5$results$RMSE, cv_m6$results$RMSE),
MAE = c(cv_m1$results$MAE, cv_m2$results$MAE, cv_m3$results$MAE,
cv_m4$results$MAE, cv_m5$results$MAE, cv_m6$results$MAE)
)
fe_m4 <- feols(
sale_price ~ beds + baths + basements + interior + exterior + liv_area + poly(age, 2) +
violent_2blocks + dist_park_mi + foodretail_1mi_count + dist_school_public_ft +
vacancy_rate + med_gross_rent + med_hh_income + pct_ba_plus + pct_black + pct_white +
poverty_rate + unemployment_rate + pct_age_25_44 + pct_age_65plus +
mkt_value |                    # left of | = regular covariates
neigh_cv,                      # right of | = fixed effect(s) to absorb
data = clean_data
)
# Pretty table (no neighborhood FE dummies will show)
modelsummary(
list("Final Model (FE absorbed)" = fe_m4),
gof_omit  = 'IC|Adj|Log|F',
statistic = "({std.error})",     # <-- this is the important change
estimate  = "{estimate}{stars}",
stars     = c('*'=.1,'**'=.05,'***'=.01),
output    = "markdown"
)
lm_model4 <- cv_m4$finalModel
# Residual Plot
clean_data$residuals <- residuals(lm_model4)
clean_data$fitted <- fitted(lm_model4)
ggplot(clean_data, aes(x = fitted, y = residuals)) +
geom_point() +
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
labs(title = "Residual Plot", x = "Fitted Values", y = "Residuals") +
theme_minimal()
# Breusch-Pagan Test for Heteroskedacity
library(lmtest)
bptest(lm_model4)
# Plot Q-Q Plot to test Normality of Residuals
q <- ggplot(clean_data, aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = "Q-Q Plot of Residuals in House Price Prediction",
x = "Theoretical Quantiles",
y = "Sample Quantiles") +
theme_minimal()
print(q)
# Add diagnostic measures to tibble
diagnostic_data <- augment(lm_model4, data = clean_data) |>
mutate(
cooks_d = .cooksd,
leverage = .hat,
is_influential = cooks_d > 4/nrow(clean_data)
)
# Plot Cook's distance
ggplot(diagnostic_data, aes(x = 1:nrow(diagnostic_data), y = cooks_d)) +
geom_point(aes(color = is_influential), size = 2) +
geom_hline(yintercept = 4/nrow(diagnostic_data),
linetype = "dashed", color = "red") +
scale_color_manual(values = c("grey60", "red")) +
labs(title = "Cook's Distance",
x = "Observation", y = "Cook's D") +
theme_minimal() +
theme(legend.position = "none")
# Rule of thumb: Cook's D > 4/n
threshold <- 4/nrow(clean_data)
influential <- diagnostic_data |>
filter(cooks_d > threshold)  |>
select(age, baths, beds, mkt_value, liv_area, sale_price, neigh, cooks_d) |>
arrange(desc(cooks_d))
head(influential, 10)
#| label: resid-maps
#| fig-width: 12
#| fig-height: 8
#| warning: false
#| message: false
neigh_url <- "https://raw.githubusercontent.com/opendataphilly/open-geo-data/refs/heads/master/philadelphia-neighborhoods/philadelphia-neighborhoods.geojson"
neigh <- sf::read_sf(neigh_url)
# make sure neigh has a character neighborhood name column we can join on
# most Philly neighborhood layers use NAME
if (!"NAME" %in% names(neigh)) {
stop("Neighborhood layer is missing NAME column; inspect `names(neigh)`.")
}
############################################################
# 1. Add per-model predictions & residuals to clean_data
############################################################
clean_data <- clean_data %>%
mutate(
pred_m1  = predict(cv_m1, newdata = clean_data),
resid_m1 = sale_price - pred_m1,
pred_m2  = predict(cv_m2, newdata = clean_data),
resid_m2 = sale_price - pred_m2,
pred_m4  = predict(cv_m4, newdata = clean_data),
resid_m4 = sale_price - pred_m4,
pred_m5  = predict(cv_m5, newdata = clean_data),
resid_m5 = sale_price - pred_m5,
pred_m6  = predict(cv_m6, newdata = clean_data),
resid_m6 = sale_price - pred_m6
)
# standardize neighborhood name text in the sales rows
clean_data_std <- clean_data %>%
mutate(
neigh = neigh %>%
as.character() %>%
str_trim()
)
############################################################
# 2. Collapse residuals to neighborhood-level stats
############################################################
neigh_resid_long <- clean_data_std %>%
select(neigh, starts_with("resid_")) %>%
pivot_longer(
cols = starts_with("resid_"),
names_to = "model",
values_to = "resid"
) %>%
mutate(
# keep only the models we care about
model = factor(
model,
levels = c("resid_m1", "resid_m2", "resid_m4", "resid_m5", "resid_m6"),
labels = c("Model 1", "Model 2", "Model 4", "Model 5", "Model 6")
)
) %>%
filter(!is.na(model)) %>%  # drop any others
group_by(neigh, model) %>%
summarise(
n_sales    = n(),
mean_res   = mean(resid, na.rm = TRUE),                     # avg under/over
median_res = median(resid, na.rm = TRUE),
rmse_res   = sqrt(mean(resid^2, na.rm = TRUE)),
.groups    = "drop"
)
############################################################
# 3. Join neighborhood stats back to neighborhood polygons
############################################################
neigh_map_all <- neigh %>%
mutate(
neigh = NAME %>%
as.character() %>%
str_trim()
) %>%
left_join(neigh_resid_long, by = "neigh")
# neigh_map_all is now sf with columns:
# neigh, model, mean_res, etc.
############################################################
# 4. Helper: map residuals for ONE model
#    - dynamic symmetric color scale per model
#    - simple title (Model 1, etc), no subtitle in panels
############################################################
plot_neigh_residual_map <- function(model_label, na_col = "grey90") {
df <- neigh_map_all %>% filter(model == model_label)
# symmetric color limit per model
lim_sym <- max(abs(df$mean_res), na.rm = TRUE)
if (!is.finite(lim_sym) || lim_sym <= 0) {
lim_sym <- NA_real_
}
ggplot(df) +
geom_sf(
aes(fill = mean_res),
color = "grey40",
linewidth = 0.2
) +
scale_fill_gradient2(
name      = "Mean residual (USD)",
low       = "#a4133c",
mid       = "white",
high      = "#1a759f",
midpoint  = 0,
limits    = if (is.finite(lim_sym)) c(-lim_sym, lim_sym) else waiver(),
oob       = squish,
na.value  = na_col,
labels    = dollar
) +
labs(
title = model_label,
x = NULL,
y = NULL
) +
theme_minimal(base_size = 11) +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.title       = element_text(face = "bold", size = 12, hjust = 0),
axis.text        = element_blank(),
axis.ticks       = element_blank(),
legend.position  = "right"
)
}
############################################################
# 5. Build panels for each model (dropping Model 3)
############################################################
p_model1 <- plot_neigh_residual_map("Model 1")
p_model2 <- plot_neigh_residual_map("Model 2")
p_model4 <- plot_neigh_residual_map("Model 4")
p_model5 <- plot_neigh_residual_map("Model 5")
p_model6 <- plot_neigh_residual_map("Model 6")
blank_panel <- ggplot() + theme_void()
############################################################
# 6. Assemble patchwork figure (2x3 grid layout)
############################################################
resid_maps_all <-
(p_model1 | p_model2 | p_model4) /
(p_model5 | p_model6 | blank_panel) +
plot_annotation(
title = "Which Neighborhoods Are Hardest to Predict?",
subtitle = paste(
"Mean model residual (USD) by neighborhood.",
"Blue = model underpredicts (homes sold for MORE than predicted).",
"Red = model overpredicts (homes sold for LESS).",
sep = "\n"
),
theme = theme(
plot.title    = element_text(face = "bold", size = 16, hjust = 0),
plot.subtitle = element_text(size = 11, hjust = 0)
)
) &
theme(
legend.key.height = unit(0.4, "in"),
legend.key.width  = unit(0.15, "in")
)
############################################################
# 7. Print final figure for the slide
############################################################
print(resid_maps_all)
